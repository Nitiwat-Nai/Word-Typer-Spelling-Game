<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Typer: English Spelling Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
            overflow: hidden;
        }

        .container::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: backgroundMove 20s linear infinite;
            pointer-events: none;
        }

        @keyframes backgroundMove {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(50px, 50px);
            }
        }

        #gameTitle {
            font-size: clamp(24px, 6vw, 36px);
            font-weight: 800;
            color: #ffffff;
            text-align: center;
            padding: 15px 10px;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
            z-index: 10;
            cursor: pointer;
        }

        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        /* UPDATED: Auto Play Beat Animation - Slower */
        .auto-play-active {
            animation: gradientShift 3s ease infinite, beat 0.8s infinite alternate !important;
            /* Slower beat 0.8s */
        }

        @keyframes beat {
            from {
                transform: scale(1.0);
                opacity: 0.9;
            }

            to {
                transform: scale(1.03);
                opacity: 1;
            }
        }

        #topBar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            gap: 10px;
            z-index: 10;
        }

        .score-box,
        .time-box,
        .control-btn {
            padding: 10px 15px;
            border-radius: 15px;
            font-weight: 700;
            font-size: clamp(12px, 3.5vw, 16px);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: none;
            white-space: nowrap;
        }

        .score-box {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            color: white;
            flex: 1;
            text-align: center;
        }

        .time-box {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            flex: 1;
            text-align: center;
        }

        .control-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #333;
            font-weight: 800;
            flex: 1.2;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            flex: 1;
            width: 100%;
            background: linear-gradient(180deg, #ffecd2 0%, #fcb69f 100%);
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.1);
            margin: 0;
            display: block;
        }

        #inputBox {
            width: 100%;
            padding: 15px;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        #currentInput {
            font-size: clamp(20px, 5vw, 32px);
            font-weight: 800;
            color: #ffffff;
            letter-spacing: 8px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            display: inline-block;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .typed-error {
            color: #ff4757;
            animation: shake 0.3s;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-10px);
            }

            75% {
                transform: translateX(10px);
            }
        }

        #virtualKeyboard {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .key-button {
            background: linear-gradient(135deg, #ffffff 0%, #e0e0e0 100%);
            color: #333;
            border: none;
            padding: 18px 0;
            font-size: clamp(16px, 4vw, 22px);
            font-weight: 700;
            cursor: pointer;
            border-radius: 12px;
            user-select: none;
            transition: all 0.1s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            min-width: 35px;
            flex: 1;
            max-width: 55px;
            /* Added for multiline text */
            white-space: normal;
            line-height: 1.2;
            text-align: center;
        }

        .key-button:active,
        .key-active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: white !important;
            transform: scale(1.1) !important;
            /* Zoom effect */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Menu Screens Style */
        #menuScreen,
        #levelCompleteScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 20px;
            text-align: center;
            overflow-y: auto;
        }

        #menuTitle {
            font-size: clamp(28px, 7vw, 42px);
            font-weight: 900;
            color: #ffffff;
            margin-bottom: 30px;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
        }

        #menuScreen h2 {
            color: white;
            font-size: clamp(20px, 5vw, 28px);
            margin-bottom: 20px;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 800;
        }

        #levelCompleteScreen #completeMessage {
            font-size: clamp(28px, 7vw, 42px);
            font-weight: 900;
            color: #feca57;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 10px;
        }

        #levelCompleteScreen #finalScore {
            font-size: clamp(20px, 5vw, 32px);
            font-weight: 800;
            color: #ffffff;
            margin-bottom: 20px;
        }

        .menu-btn {
            width: 80%;
            max-width: 300px;
            padding: 15px 10px;
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 800;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            margin-bottom: 15px;
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        #nextLevelBtn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .menu-btn:active {
            transform: scale(0.95);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }

        #countdownOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #countdownNumber {
            font-size: clamp(80px, 20vw, 150px);
            font-weight: 900;
            color: #ffffff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        #levelButtonsContainer {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            padding: 10px;
            max-width: 600px;
            width: 100%;
        }

        .level-button {
            padding: 15px 10px;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: 800;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            overflow: hidden;
            /* Added for multiline text */
            white-space: normal;
            line-height: 1.2;
            text-align: center;
        }

        .level-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .level-button:active::before {
            width: 300px;
            height: 300px;
        }

        .level-button:active {
            transform: scale(0.95);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }

        /* Word Summary Table */
        #wordSummaryTable {
            width: 90%;
            max-width: 450px;
            margin-top: 20px;
            margin-bottom: 20px;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #wordSummaryTable th,
        #wordSummaryTable td {
            padding: 10px;
            border: 1px solid #ddd;
        }

        #wordSummaryTable th {
            background: #3a7bd5;
            color: white;
            font-size: clamp(14px, 3.5vw, 18px);
        }

        #wordSummaryTable td {
            font-size: clamp(12px, 3vw, 16px);
            color: #333;
        }

        #wordSummaryTable tr:nth-child(even) {
            background-color: #f2f2f2;
        }


        @media (max-width: 400px) {
            #levelButtonsContainer {
                grid-template-columns: repeat(5, 1fr);
                gap: 8px;
            }

            .level-button {
                padding: 12px 8px;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            #gameTitle {
                padding: 8px 10px;
            }

            #topBar {
                padding: 5px 15px;
            }

            #inputBox {
                padding: 8px;
            }

            #virtualKeyboard {
                padding: 5px;
                gap: 4px;
            }

            .key-button {
                padding: 8px 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="gameTitle">
            üìù Word Typer Game
        </div>

        <div id="topBar" style="display: none;">
            <div class="score-box">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <span id="scoreDisplay">0</span></div>
            <button id="pauseBtn" class="control-btn">‡∏´‡∏¢‡∏∏‡∏î/‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏•‡∏±‡∏Å</button>
            <div class="time-box">‡πÄ‡∏ß‡∏•‡∏≤: <span id="timeDisplay">0:00</span></div>
        </div>

        <div id="inputBox" style="display: none;">
            <span id="currentInput">‡∏£‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå...</span>
        </div>

        <canvas id="gameCanvas" style="display: none;"></canvas>

        <div id="virtualKeyboard" style="display: none;"></div>

        <div id="menuScreen">
            <div id="menuTitle">üìù Word Typer Game</div>
            <h2>üéÆ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏•‡πÄ‡∏ß‡∏• (1-10)</h2>
            <div id="levelButtonsContainer"></div>
        </div>

        <div id="levelCompleteScreen" style="display: none;">
            <div id="completeMessage">Level X Complete!</div>
            <div id="finalScore">Score: 0</div>
            <table id="wordSummaryTable"></table>
            <button id="nextLevelBtn" class="menu-btn">‡πÄ‡∏•‡πÄ‡∏ß‡∏•‡∏ñ‡∏±‡∏î‡πÑ‡∏õ üöÄ</button>
            <button id="returnToMenuBtn" class="menu-btn">‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</button>
        </div>

        <div id="countdownOverlay">
            <div id="countdownNumber">3</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const currentInputDisplay = document.getElementById('currentInput');
        const topBar = document.getElementById('topBar');
        const inputBox = document.getElementById('inputBox');
        const virtualKeyboard = document.getElementById('virtualKeyboard');
        const menuScreen = document.getElementById('menuScreen');
        const pauseBtn = document.getElementById('pauseBtn');
        const levelButtonsContainer = document.getElementById('levelButtonsContainer');
        const countdownOverlay = document.getElementById('countdownOverlay');
        const countdownNumber = document.getElementById('countdownNumber');

        const gameTitle = document.getElementById('gameTitle');
        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
        const completeMessage = document.getElementById('completeMessage');
        const finalScoreDisplay = document.getElementById('finalScore');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const returnToMenuBtnComplete = document.getElementById('returnToMenuBtn');
        const wordSummaryTable = document.getElementById('wordSummaryTable');

        let gameLoopId;

        // --- Game State Vars ---
        let isAutoPlayMode = false;
        let autoPlayTimerId = null; 
        let botTypingIntervalId = null; 
        let botCurrentCharIndex = 0;
        let isWaitingForNextIcon = false; 
        let botCurrentTarget = null; 

        // --- Speech Synthesis Logic ---
        const synth = window.speechSynthesis;
        let speechQueue = [];
        
        // NEW GLOBAL: Callback to run when the last queued speech finishes
        let levelCompleteCallback = null; 

        // Function to handle sequential speaking and transition callback
        function speakWord(word) {
            if (!synth) return null;

            const utterance = new SpeechSynthesisUtterance(word);
            
            // Setup voice/rate (optional but good practice)
            const voices = synth.getVoices();
            const enVoice = voices.find(voice => voice.lang.startsWith('en-'));
            if (enVoice) {
                utterance.voice = enVoice;
            }
            utterance.pitch = 1.0; 
            utterance.rate = 0.8; 

            speechQueue.push(utterance);
            
            // CRITICAL: Single comprehensive onend handler
            utterance.onend = () => {
                speechQueue.shift(); // 1. Remove the finished utterance

                // 2. Check if the level is complete and this was the last word's speech
                if (levelCompleteCallback) {
                    const tempCallback = levelCompleteCallback;
                    levelCompleteCallback = null; // Clear it immediately
                    
                    // Delay slightly to ensure destruction animation starts/finishes
                    setTimeout(() => { 
                         tempCallback(); 
                    }, 300); 

                } else if (speechQueue.length > 0) {
                    // 3. Normal queue processing: Start the next one
                    synth.speak(speechQueue[0]); 
                }
            };
            
            // Start speaking the first item if the queue was empty before adding this one
            if (speechQueue.length === 1 && !synth.speaking) {
                synth.speak(utterance);
            }
            return utterance; // Return the utterance object
        }

        // --- Sound Logic ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioNode = audioContext.destination; // Define audioNode for connection

        function playSound(frequency, duration, type, gain = 0.5) {
            if (!audioContext) return;
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    _play(frequency, duration, type, gain);
                });
            } else {
                _play(frequency, duration, type, gain);
            }
        }
        
        function _play(frequency, duration, type, gain) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(gain, audioContext.currentTime);

            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(audioNode);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // --- Canvas & Resize Logic ---
        function resizeCanvas() {
            const totalFixedElementsHeight = (document.getElementById('gameTitle')?.offsetHeight || 0) +
                (topBar.style.display !== 'none' ? topBar.offsetHeight : 0) +
                (inputBox.style.display !== 'none' ? inputBox.offsetHeight : 0) +
                (virtualKeyboard.style.display !== 'none' ? virtualKeyboard.offsetHeight : 0);

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - totalFixedElementsHeight;

            if (isGameRunning || menuScreen.style.display === 'none') {
                DANGER_ZONE_Y = canvas.height - 60;
            }
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // --- Word Data (Same as previous) ---
        const LEVEL_1_WORDS = [
            { icon: 'üñãÔ∏è', word: 'PEN', meaning: '‡∏õ‡∏≤‡∏Å‡∏Å‡∏≤' },
            { icon: 'üê±', word: 'CAT', meaning: '‡πÅ‡∏°‡∏ß' },
            { icon: '‚òÄÔ∏è', word: 'SUN', meaning: '‡∏û‡∏£‡∏∞‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå' },
            { icon: 'üöó', word: 'CAR', meaning: '‡∏£‡∏ñ‡∏¢‡∏ô‡∏ï‡πå' },
            { icon: 'ü¶ä', word: 'FOX', meaning: '‡∏™‡∏∏‡∏ô‡∏±‡∏Ç‡∏à‡∏¥‡πâ‡∏á‡∏à‡∏≠‡∏Å' },
            { icon: 'üêù', word: 'BEE', meaning: '‡∏ú‡∏∂‡πâ‡∏á' },
            { icon: 'ü¶ã', word: 'FLY', meaning: '‡πÅ‡∏°‡∏•‡∏á‡∏ß‡∏±‡∏ô' },
            { icon: 'üê∏', word: 'FROG', meaning: '‡∏Å‡∏ö' },
            { icon: 'üíß', word: 'DROP', meaning: '‡∏´‡∏¢‡∏î‡∏ô‡πâ‡∏≥' },
            { icon: 'üê≠', word: 'MICE', meaning: '‡∏´‡∏ô‡∏π' },
        ];
        const LEVEL_2_WORDS = [
            { icon: '‚öΩ', word: 'BALL', meaning: '‡∏•‡∏π‡∏Å‡∏ö‡∏≠‡∏•' },
            { icon: 'üßä', word: 'CUBE', meaning: '‡∏•‡∏π‡∏Å‡∏ö‡∏≤‡∏®‡∏Å‡πå' },
            { icon: 'üìò', word: 'BOOK', meaning: '‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠' },
            { icon: 'üê†', word: 'FISH', meaning: '‡∏õ‡∏•‡∏≤' },
            { icon: 'ü§∏', word: 'JUMP', meaning: '‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î' },
            { icon: 'üö∂', word: 'WALK', meaning: '‡πÄ‡∏î‡∏¥‡∏ô' },
            { icon: 'ü¶Å', word: 'LION', meaning: '‡∏™‡∏¥‡∏á‡πÇ‡∏ï' },
            { icon: 'üí°', word: 'LAMP', meaning: '‡πÇ‡∏Ñ‡∏°‡πÑ‡∏ü' },
            { icon: 'üßº', word: 'SOAP', meaning: '‡∏™‡∏ö‡∏π‡πà' },
            { icon: 'üóÑÔ∏è', word: 'DESK', meaning: '‡πÇ‡∏ï‡πä‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô' },
        ];
        const LEVEL_3_WORDS = [
            { icon: 'üçé', word: 'APPLE', meaning: '‡πÅ‡∏≠‡∏õ‡πÄ‡∏õ‡∏¥‡∏•' },
            { icon: 'üåü', word: 'STAR', meaning: '‡∏î‡∏≤‡∏ß' },
            { icon: 'üè†', word: 'HOUSE', meaning: '‡∏ö‡πâ‡∏≤‡∏ô' },
            { icon: 'üå≥', word: 'TREE', meaning: '‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ' },
            { icon: 'üî•', word: 'FIRE', meaning: '‡πÑ‡∏ü' },
            { icon: 'üêö', word: 'SHELL', meaning: '‡πÄ‡∏õ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏≠‡∏¢' },
            { icon: 'üöÇ', word: 'TRAIN', meaning: '‡∏£‡∏ñ‡πÑ‡∏ü' },
            { icon: 'ü™ë', word: 'CHAIR', meaning: '‡πÄ‡∏Å‡πâ‡∏≤‡∏≠‡∏µ‡πâ' },
            { icon: 'üí¶', word: 'WATER', meaning: '‡∏ô‡πâ‡∏≥' },
            { icon: 'üß§', word: 'GLOVE', meaning: '‡∏ñ‡∏∏‡∏á‡∏°‡∏∑‡∏≠' },
        ];
        const LEVEL_4_WORDS = [
            { icon: 'üê¶', word: 'CROW', meaning: '‡∏≠‡∏µ‡∏Å‡∏≤' },
            { icon: 'üí°', word: 'LIGHT', meaning: '‡πÅ‡∏™‡∏á' },
            { icon: 'üìû', word: 'PHONE', meaning: '‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå' },
            { icon: 'ü™ô', word: 'MONEY', meaning: '‡πÄ‡∏á‡∏¥‡∏ô' },
            { icon: 'ü¶¢', word: 'SWAN', meaning: '‡∏´‡∏á‡∏™‡πå' },
            { icon: 'ü•É', word: 'GLASS', meaning: '‡πÅ‡∏Å‡πâ‡∏ß' },
            { icon: 'üëÑ', word: 'MOUTH', meaning: '‡∏õ‡∏≤‡∏Å' },
            { icon: 'üëÉ', word: 'NOSE', meaning: '‡∏à‡∏°‡∏π‡∏Å' },
            { icon: '‚úã', word: 'HANDS', meaning: '‡∏°‡∏∑‡∏≠' },
            { icon: 'ü¶∂', word: 'FOOT', meaning: '‡πÄ‡∏ó‡πâ‡∏≤' },
        ];
        const LEVEL_5_WORDS = [
            { icon: 'üëë', word: 'CROWN', meaning: '‡∏°‡∏á‡∏Å‡∏∏‡∏é' },
            { icon: 'üåä', word: 'OCEAN', meaning: '‡∏°‡∏´‡∏≤‡∏™‡∏°‡∏∏‡∏ó‡∏£' },
            { icon: 'üï∞Ô∏è', word: 'CLOCK', meaning: '‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤' },
            { icon: 'üç™', word: 'COOKIE', meaning: '‡∏Ñ‡∏∏‡∏Å‡∏Å‡∏µ‡πâ' },
            { icon: 'üîë', word: 'KEY', meaning: '‡∏Å‡∏∏‡∏ç‡πÅ‡∏à' },
            { icon: 'üß±', word: 'BRICK', meaning: '‡∏≠‡∏¥‡∏ê' },
            { icon: 'üß≤', word: 'MAGNET', meaning: '‡πÅ‡∏°‡πà‡πÄ‡∏´‡∏•‡πá‡∏Å' },
            { icon: 'üìå', word: 'PIN', meaning: '‡∏´‡∏°‡∏∏‡∏î' },
            { icon: 'üïØÔ∏è', word: 'CANDLE', meaning: '‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô' },
            { icon: '‚úèÔ∏è', word: 'PENCIL', meaning: '‡∏î‡∏¥‡∏ô‡∏™‡∏≠' },
        ];
        const LEVEL_6_WORDS = [
            { icon: 'üé∏', word: 'GUITAR', meaning: '‡∏Å‡∏µ‡∏ï‡∏≤‡∏£‡πå' },
            { icon: 'üöÄ', word: 'ROCKET', meaning: '‡∏à‡∏£‡∏ß‡∏î' },
            { icon: 'ü•á', word: 'MEDAL', meaning: '‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç' },
            { icon: 'üßÖ', word: 'ONION', meaning: '‡∏´‡∏±‡∏ß‡∏´‡∏≠‡∏°' },
            { icon: 'üß©', word: 'PUZZLE', meaning: '‡∏õ‡∏£‡∏¥‡∏®‡∏ô‡∏≤' },
            { icon: 'ü•´', word: 'SAUCE', meaning: '‡∏ã‡∏≠‡∏™' },
            { icon: 'üëï', word: 'SHIRT', meaning: '‡πÄ‡∏™‡∏∑‡πâ‡∏≠' },
            { icon: '‚òï', word: 'COFFEE', meaning: '‡∏Å‡∏≤‡πÅ‡∏ü' },
            { icon: 'üçµ', word: 'TEA', meaning: '‡∏ä‡∏≤' },
            { icon: 'ü•§', word: 'JUICE', meaning: '‡∏ô‡πâ‡∏≥‡∏ú‡∏•‡πÑ‡∏°‡πâ' },
        ];
        const LEVEL_7_WORDS = [
            { icon: 'üíø', word: 'ALBUM', meaning: '‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°' },
            { icon: 'üå∏', word: 'FLOWER', meaning: '‡∏î‡∏≠‡∏Å‡πÑ‡∏°‡πâ' },
            { icon: 'üì∑', word: 'CAMERA', meaning: '‡∏Å‡∏•‡πâ‡∏≠‡∏á' },
            { icon: 'ü™ü', word: 'WINDOW', meaning: '‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á' },
            { icon: '‚òÅÔ∏è', word: 'CLOUD', meaning: '‡πÄ‡∏°‡∏Ü' },
            { icon: 'üòä', word: 'HAPPY', meaning: '‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç' },
            { icon: 'üò¥', word: 'SLEEP', meaning: '‡∏ô‡∏≠‡∏ô' },
            { icon: '‚úçÔ∏è', word: 'WRITE', meaning: '‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô' },
            { icon: 'üìñ', word: 'READ', meaning: '‡∏≠‡πà‡∏≤‡∏ô' },
            { icon: 'üèûÔ∏è', word: 'RIVER', meaning: '‡πÅ‡∏°‡πà‡∏ô‡πâ‡∏≥' },
        ];
        const LEVEL_8_WORDS = [
            { icon: 'üêß', word: 'PENGUIN', meaning: '‡∏ô‡∏Å‡πÄ‡∏û‡∏ô‡∏Å‡∏ß‡∏¥‡∏ô' },
            { icon: 'ü™°', word: 'NEEDLE', meaning: '‡πÄ‡∏Ç‡πá‡∏°' },
            { icon: 'ü™ñ', word: 'HELMET', meaning: '‡∏´‡∏°‡∏ß‡∏Å‡∏Å‡∏±‡∏ô‡∏ô‡πá‡∏≠‡∏Å' },
            { icon: 'ü™§', word: 'TRAP', meaning: '‡∏Å‡∏±‡∏ö‡∏î‡∏±‡∏Å' },
            { icon: 'üó≥Ô∏è', word: 'VOTE', meaning: '‡πÇ‡∏´‡∏ß‡∏ï' },
            { icon: 'üõí', word: 'CART', meaning: '‡∏ï‡∏∞‡∏Å‡∏£‡πâ‡∏≤' },
            { icon: 'üìê', word: 'RULER', meaning: '‡πÑ‡∏°‡πâ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î' },
            { icon: 'üèõÔ∏è', word: 'TEMPLE', meaning: '‡∏ß‡∏±‡∏î/‡∏ß‡∏¥‡∏´‡∏≤‡∏£' },
            { icon: 'üè¢', word: 'OFFICE', meaning: '‡∏™‡∏≥‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô' },
            { icon: 'üõ£Ô∏è', word: 'HIGHWAY', meaning: '‡∏ó‡∏≤‡∏á‡∏î‡πà‡∏ß‡∏ô' },
        ];
        const LEVEL_9_WORDS = [
            { icon: 'üéà', word: 'BALLOON', meaning: '‡∏•‡∏π‡∏Å‡πÇ‡∏õ‡πà‡∏á' },
            { icon: 'üêò', word: 'ELEPHANT', meaning: '‡∏ä‡πâ‡∏≤‡∏á' },
            { icon: 'üêí', word: 'MONKEY', meaning: '‡∏•‡∏¥‡∏á' },
            { icon: '‚òÇÔ∏è', word: 'UMBRELLA', meaning: '‡∏£‡πà‡∏°' },
            { icon: 'ü•ï', word: 'CARROT', meaning: '‡πÅ‡∏Ñ‡∏£‡∏≠‡∏ó' },
            { icon: 'üõµ', word: 'SCOOTER', meaning: '‡∏™‡∏Å‡∏π‡πä‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡πå' },
            { icon: 'üè∞', word: 'CASTLE', meaning: '‡∏õ‡∏£‡∏≤‡∏™‡∏≤‡∏ó' },
            { icon: 'üíé', word: 'DIAMOND', meaning: '‡πÄ‡∏û‡∏ä‡∏£' },
            { icon: 'üéπ', word: 'PIANO', meaning: '‡πÄ‡∏õ‡∏µ‡∏¢‡πÇ‡∏ô' },
            { icon: 'üñºÔ∏è', word: 'PICTURE', meaning: '‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û' },
        ];
        const LEVEL_10_WORDS = [
            { icon: 'üóø', word: 'STATUE', meaning: '‡∏£‡∏π‡∏õ‡∏õ‡∏±‡πâ‡∏ô' },
            { icon: 'ü™ú', word: 'LADDER', meaning: '‡∏ö‡∏±‡∏ô‡πÑ‡∏î' },
            { icon: 'ü¶í', word: 'GIRAFFE', meaning: '‡∏¢‡∏µ‡∏£‡∏≤‡∏ü' },
            { icon: 'ü¶ï', word: 'DINOSAUR', meaning: '‡πÑ‡∏î‡πÇ‡∏ô‡πÄ‡∏™‡∏≤‡∏£‡πå' },
            { icon: 'ü™£', word: 'BUCKET', meaning: '‡∏ñ‡∏±‡∏á' },
            { icon: 'ü™ó', word: 'ACCORDION', meaning: '‡∏´‡∏µ‡∏ö‡πÄ‡∏û‡∏•‡∏á' },
            { icon: 'üõ∞Ô∏è', word: 'SATELLITE', meaning: '‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏°' },
            { icon: 'üí∏', word: 'PAYMENT', meaning: '‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô' },
            { icon: 'üìÆ', word: 'POSTBOX', meaning: '‡∏ï‡∏π‡πâ‡πÑ‡∏õ‡∏£‡∏©‡∏ì‡∏µ‡∏¢‡πå' },
            { icon: 'üîñ', word: 'BOOKMARK', meaning: '‡∏ó‡∏µ‡πà‡∏Ñ‡∏±‡πà‡∏ô‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠' },
        ];
        const ALL_LEVEL_WORDS = [
            LEVEL_1_WORDS, LEVEL_2_WORDS, LEVEL_3_WORDS, LEVEL_4_WORDS, LEVEL_5_WORDS,
            LEVEL_6_WORDS, LEVEL_7_WORDS, LEVEL_8_WORDS, LEVEL_9_WORDS, LEVEL_10_WORDS
        ];

        const BASE_SPEED = 1.0;
        const BASE_DROP_INTERVAL = 300; 

        let DANGER_ZONE_Y;
        let usedWordsInLevel = new Set();
        let currentLevelWordData = [];

        let score = 0;
        let startTime = 0;
        let runningTime = 0;
        let fallingIcons = [];
        let timeSinceLastDrop = 0;

        const TOTAL_WORDS_TO_COLLECT = 10;

        let dropInterval;
        let isGameRunning = false;
        let currentLevel = 0;
        let levelWords = [];
        let wordsCollected = 0;

        // --- Auto Play Logic ---

        function toggleAutoPlay() {
            isAutoPlayMode = !isAutoPlayMode;
            if (isAutoPlayMode) {
                gameTitle.classList.add('auto-play-active');
                console.log("Auto Play Mode: ON");
            } else {
                gameTitle.classList.remove('auto-play-active');
                console.log("Auto Play Mode: OFF");
            }
        }

        // Double click/tap event to toggle bot mode ONLY from main screen
        gameTitle.addEventListener('dblclick', toggleAutoPlay);
        
        let lastTap = 0;
        gameTitle.addEventListener('touchend', function(event) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            // Check if it's a double tap (within 500ms)
            if (tapLength < 500 && tapLength > 50) { 
                toggleAutoPlay();
                event.preventDefault(); 
            }
            lastTap = currentTime;
        });

        // NEW: Function to find the active target for the bot
        function findBotTarget() {
            // Find the first icon that is NOT in the process of being destroyed
            return fallingIcons.find(icon => !icon.isDestroying); 
        }

        function startAutoPlay() {
            stopAutoPlay();
            if (!isAutoPlayMode || !isGameRunning) return;

            // Start by waiting for the first non-destroying icon to appear
            isWaitingForNextIcon = true; 
        }

        function stopAutoPlay() {
            if (autoPlayTimerId) clearTimeout(autoPlayTimerId);
            if (botTypingIntervalId) clearInterval(botTypingIntervalId);
            autoPlayTimerId = null;
            botTypingIntervalId = null;
            botCurrentCharIndex = 0;
            botCurrentTarget = null; // Clear the target
            // isWaitingForNextIcon is often set to true when stop is called to prepare for the next word
        }

        /**
         * Core function to handle the delayed typing for the current word.
         */
        function processNextWordForBot() {
            const targetIcon = findBotTarget();

            // Guard: If no valid target is found, or mode is off, reset state and wait.
            if (!isAutoPlayMode || !isGameRunning || !targetIcon) {
                stopAutoPlay();
                isWaitingForNextIcon = true; // Ensure it keeps trying 
                return; 
            }
            
            // Guard: Prevent re-triggering if a process is already underway
            if (autoPlayTimerId !== null || botTypingIntervalId !== null) return;

            // Set the target and start the process
            botCurrentTarget = targetIcon;
            isWaitingForNextIcon = false; 

            const targetWord = botCurrentTarget.targetWord;
            botCurrentCharIndex = 0;
            
            console.log(`Bot is targeting: ${targetWord}`);

            // Delay 1 second before starting to type the first character (Requirement 1)
            autoPlayTimerId = setTimeout(() => {
                
                // Start typing characters with 0.5s interval (Requirement 1)
                botTypingIntervalId = setInterval(() => {
                    // Robust check: If game ends, or target is destroyed (by external force), exit.
                    if (!isGameRunning || botCurrentTarget.isDestroying) { 
                        stopAutoPlay();
                        isWaitingForNextIcon = true; 
                        return;
                    }

                    if (botCurrentCharIndex < targetWord.length) {
                        const char = targetWord[botCurrentCharIndex];
                        handleInput(char); 
                        botCurrentCharIndex++;
                    } else {
                        // This block should ideally not be hit if handleInput works, but as safety:
                        clearInterval(botTypingIntervalId);
                        botTypingIntervalId = null;
                        isWaitingForNextIcon = true; 
                        console.log("Bot finished word (safety exit), waiting for next icon.");
                    }
                }, 500); // 0.5 second interval for characters
                autoPlayTimerId = null; // Clear the timeout ID now that interval has started
            }, 1000); // 1 second delay before starting to type
        }

        // --- Game Flow Functions ---

        function generateLevels() {
            levelButtonsContainer.innerHTML = '';
            levelCompleteScreen.style.display = 'none';

            for (let i = 0; i < 10; i++) {
                const button = document.createElement('button');
                button.className = 'level-button';
                let range;
                if (i < 2) range = '3-4';
                else if (i < 4) range = '4-5';
                else if (i < 8) range = '5-6';
                else range = '6-8';

                // Use innerHTML and <br> for multiline display
                button.innerHTML = `L${i + 1} <br> (${range})`; 
                button.onclick = () => startGame(i);
                levelButtonsContainer.appendChild(button);
            }
        }

        async function startGame(levelIndex) {
            currentLevel = levelIndex;
            currentLevelWordData = [...ALL_LEVEL_WORDS[levelIndex]].sort(() => Math.random() - 0.5); 
            levelWords = currentLevelWordData;
            usedWordsInLevel.clear();

            dropInterval = BASE_DROP_INTERVAL;
            
            score = 0;
            startTime = Date.now();
            fallingIcons.length = 0;
            wordsCollected = 0;
            scoreDisplay.textContent = score;
            currentInputDisplay.textContent = '‡∏£‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå...';
            stopAutoPlay(); 
            
            // Clear speech queue and completion flag
            if (synth) synth.cancel();
            speechQueue.length = 0;
            levelCompleteCallback = null; // Ensure this is clean


            menuScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            canvas.style.display = 'block';
            topBar.style.display = 'flex';
            inputBox.style.display = 'block';
            virtualKeyboard.style.display = 'flex';

            resizeCanvas();
            DANGER_ZONE_Y = canvas.height - 60;

            await showCountdown();

            // Delay 1 second after countdown before starting the game/drop logic
            setTimeout(() => {
                timeSinceLastDrop = dropInterval; 
                isGameRunning = true;
                if (!gameLoopId) {
                    gameLoop();
                }

                // Start bot logic preparation (waits for first icon)
                startAutoPlay();
            }, 1000); 
        }

        function createWordSummaryTable() {
            wordSummaryTable.innerHTML = '';
            let tableHTML = '<tr><th>#</th><th>Word (‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå)</th><th>Meaning (‡∏Ñ‡∏≥‡πÅ‡∏õ‡∏•)</th></tr>';

            currentLevelWordData.forEach((data, index) => {
                tableHTML += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${data.word}</td>
                        <td>${data.meaning}</td>
                    </tr>
                `;
            });

            wordSummaryTable.innerHTML = tableHTML;
        }

        function showLevelCompleteScreen() {
            // This function is now only called via the audio callback after the last word
            isGameRunning = false;
            fallingIcons.length = 0;
            stopAutoPlay(); 
            if (synth) synth.cancel();
            speechQueue.length = 0;
            levelCompleteCallback = null; // Clean up just in case

            canvas.style.display = 'none';
            topBar.style.display = 'none';
            inputBox.style.display = 'none';
            virtualKeyboard.style.display = 'none';

            levelCompleteScreen.style.display = 'flex';

            completeMessage.textContent = `Level ${currentLevel + 1} Complete! üéâ`;
            finalScoreDisplay.textContent = `Final Score: ${score}`;
            createWordSummaryTable(); 

            if (currentLevel < ALL_LEVEL_WORDS.length - 1) {
                nextLevelBtn.style.display = 'block';
                nextLevelBtn.onclick = () => {
                    if (currentLevel + 1 < ALL_LEVEL_WORDS.length) {
                        startGame(currentLevel + 1);
                    } else {
                        returnToMenu();
                    }
                };
            } else {
                nextLevelBtn.style.display = 'none';
                completeMessage.textContent = `All Levels Complete! üèÜ`;
            }
            returnToMenuBtnComplete.onclick = returnToMenu;
        }

        function showCountdown() {
            return new Promise((resolve) => {
                countdownOverlay.style.display = 'flex';
                let count = 3;
                countdownNumber.textContent = count;

                const countInterval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        countdownNumber.textContent = count;
                        countdownNumber.style.animation = 'none';
                        setTimeout(() => {
                            countdownNumber.style.animation = 'countdownPulse 1s ease-in-out';
                        }, 10);
                    } else {
                        clearInterval(countInterval);
                        countdownOverlay.style.display = 'none';
                        resolve();
                    }
                }, 1000);
            });
        }

        function returnToMenu() {
            isGameRunning = false;
            fallingIcons.length = 0;
            stopAutoPlay(); 
            if (synth) synth.cancel();
            speechQueue.length = 0;
            levelCompleteCallback = null; // Clean up

            canvas.style.display = 'none';
            topBar.style.display = 'none';
            inputBox.style.display = 'none';
            virtualKeyboard.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            menuScreen.style.display = 'flex';
        }

        function createWordIcon() {
            let availableWords = levelWords.filter(w => !usedWordsInLevel.has(w.word));

            if (availableWords.length === 0) {
                usedWordsInLevel.clear();
                availableWords = levelWords;
            }

            const wordData = availableWords[Math.floor(Math.random() * availableWords.length)];
            usedWordsInLevel.add(wordData.word);

            const baseSpeed = BASE_SPEED;

            return {
                x: Math.random() * (canvas.width - 60) + 30,
                y: -50,
                icon: wordData.icon,
                targetWord: wordData.word.toUpperCase(),
                remainingLetters: wordData.word.toUpperCase(),
                speed: baseSpeed,
                isDestroying: false,
                destroyScale: 1,
                iconSize: 40,
                baseSpeed: baseSpeed
            };
        }

        // --- Game Loop Logic ---
        function update() {
            // Only run if the game is active (or if waiting for completion callback)
            if (!isGameRunning && !levelCompleteCallback) return;

            // Only update game state (movement, drops) if game is running
            if (isGameRunning) {
                runningTime = Date.now() - startTime;
                timeDisplay.textContent = formatTime(runningTime);
                
                timeSinceLastDrop++;
                
                if (timeSinceLastDrop >= dropInterval && wordsCollected < TOTAL_WORDS_TO_COLLECT) {
                    if (levelWords.length > 0) {
                        fallingIcons.push(createWordIcon());
                    }
                    timeSinceLastDrop = 0;
                }
            } 
            
            // This part runs regardless of isGameRunning to allow destruction animation cleanup
            for (let i = fallingIcons.length - 1; i >= 0; i--) {
                const icon = fallingIcons[i];

                if (icon.isDestroying) {
                    icon.destroyScale += 0.1;
                    icon.iconSize += 2;
                    if (icon.destroyScale > 2) {
                        fallingIcons.splice(i, 1);
                    }
                } else {
                    if (isGameRunning) {
                        if (icon.remainingLetters.length < icon.targetWord.length / 2) {
                            icon.speed = icon.baseSpeed * 1.2;
                        }

                        icon.y += icon.speed;

                        // Score Deduction 
                        if (icon.y + icon.iconSize / 2 > DANGER_ZONE_Y) {
                            playSound(150, 0.15, 'sine', 0.8); 

                            score -= 15;
                            if (score < 0) score = 0;
                            scoreDisplay.textContent = score;

                            fallingIcons.splice(i, 1);
                            // If an icon is missed, the bot should try to target the new first icon
                            if (isAutoPlayMode && fallingIcons.length > 0) {
                                stopAutoPlay();
                                isWaitingForNextIcon = true;
                            }

                            continue;
                        }
                    }
                }
            }

            // --- Corrected Bot Trigger Logic ---
            // Only attempt to trigger bot if game is running
            if (isGameRunning && isAutoPlayMode && isWaitingForNextIcon) {
                 processNextWordForBot(); 
            }
        }

        function draw() {
            // Only draw if we are in game mode or cleaning up after a word is completed
            if (menuScreen.style.display === 'flex' && levelCompleteScreen.style.display === 'none') return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Danger Zone
            ctx.strokeStyle = '#ff4757';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, DANGER_ZONE_Y);
            ctx.lineTo(canvas.width, DANGER_ZONE_Y);
            ctx.stroke();

            // Flashing effect for Danger Zone (only while running)
            if (isGameRunning && Math.floor(runningTime / 150) % 2 === 0) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
                ctx.fillRect(0, DANGER_ZONE_Y - 5, canvas.width, 10);
            }

            fallingIcons.forEach(icon => {
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.globalAlpha = icon.isDestroying ? 2 - icon.destroyScale : 1;
                ctx.font = `${icon.iconSize}px Arial`;
                ctx.fillText(icon.icon, icon.x, icon.y);
                ctx.globalAlpha = 1;

                if (!icon.isDestroying) {
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = '#1a237e';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.strokeText(icon.remainingLetters, icon.x, icon.y + icon.iconSize / 2 + 15);
                    ctx.fillText(icon.remainingLetters, icon.x, icon.y + icon.iconSize / 2 + 15);
                }
            });

            // Draw collected word count
            ctx.font = 'bold 20px Arial';
            ctx.fillStyle = '#1a237e';
            ctx.textAlign = 'left';
            ctx.fillText(`Collected: ${wordsCollected} / ${TOTAL_WORDS_TO_COLLECT}`, 10, 30);
        }

        // --- Input and Utility Functions ---
        function createVirtualKeyboard() {
            const rows = [
                "QWERTYUIOP",
                "ASDFGHJKL",
                "ZXCVBNM"
            ];

            virtualKeyboard.innerHTML = '';

            rows.forEach(rowKeys => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';

                for (let i = 0; i < rowKeys.length; i++) {
                    const key = rowKeys[i];
                    const button = document.createElement('button');
                    button.className = 'key-button';
                    button.id = `key-${key}`; 
                    button.textContent = key;
                    button.onclick = () => handleInput(key);
                    rowDiv.appendChild(button);
                }
                virtualKeyboard.appendChild(rowDiv);
            });
        }

        document.addEventListener('keydown', (e) => {
            if (isGameRunning && !isAutoPlayMode) { 
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                handleInput(e.key.toUpperCase());
            }
        });

        function applyKeyEffect(key, duration = 100) {
            const keyButton = document.getElementById(`key-${key}`);
            if (keyButton) {
                keyButton.classList.add('key-active');
                setTimeout(() => {
                    keyButton.classList.remove('key-active');
                }, duration);
            }
        }

        function handleInput(typedKey) {
            // Allow input only if the game is running OR if we are processing the last word (wordsCollected == TOTAL_WORDS_TO_COLLECT - 1)
            // Note: Since wordsCollected is checked *after* increment, we only need to check isGameRunning for normal input
            if (!isGameRunning && wordsCollected < TOTAL_WORDS_TO_COLLECT) {
                 // But we must allow the last key of the last word to pass through.
                 // We don't need this complex check if we ensure isGameRunning is only false at the end.
                 // Let's rely on the check inside the loop.
            }


            if (typedKey.length !== 1 || typedKey < 'A' || typedKey > 'Z') {
                return;
            }

            applyKeyEffect(typedKey);

            let foundMatch = false;

            for (let i = 0; i < fallingIcons.length; i++) {
                const icon = fallingIcons[i];
                if (icon.isDestroying) continue;

                const matchIndex = icon.remainingLetters.indexOf(typedKey);

                if (matchIndex !== -1) {
                    foundMatch = true;
                    
                    playSound(600, 0.08, 'square', 0.6); 

                    icon.remainingLetters = icon.remainingLetters.slice(0, matchIndex) +
                        icon.remainingLetters.slice(matchIndex + 1);

                    if (icon.remainingLetters.length === 0) {
                        playSound(300, 0.2, 'sine', 0.7); 

                        score += 10 + Math.floor((DANGER_ZONE_Y - icon.y) / 10);
                        scoreDisplay.textContent = score;
                        icon.isDestroying = true;

                        // Speak the word immediately
                        const utterance = speakWord(icon.targetWord);

                        wordsCollected++;
                        
                        // If word is completed and Auto Play is on, stop the typing process and wait for the next icon
                        if (isAutoPlayMode) { 
                            stopAutoPlay(); 
                            isWaitingForNextIcon = true; 
                        }
                        
                        if (wordsCollected >= TOTAL_WORDS_TO_COLLECT) {
                            // 1. Stop the game logic (drops, bot, time) immediately
                            isGameRunning = false; 
                            stopAutoPlay(); // Stop bot just in case

                            const finalizeLevelTransition = () => {
                                // This function is executed by the utterance.onend handler
                                showLevelCompleteScreen();
                            };

                            if (utterance) {
                                // 2. Set the global callback to be triggered when this *last* utterance finishes
                                levelCompleteCallback = finalizeLevelTransition;
                            } else {
                                // 2. Fallback if speech is disabled/not supported (Call immediately)
                                finalizeLevelTransition();
                            }
                        }
                    }

                    currentInputDisplay.textContent = typedKey;

                    break;
                }
            }

            if (!foundMatch) {
                playSound(150, 0.15, 'sine', 0.8); 
                
                currentInputDisplay.textContent = typedKey;
                currentInputDisplay.classList.add('typed-error');
                setTimeout(() => {
                    currentInputDisplay.classList.remove('typed-error');
                    if (isGameRunning) currentInputDisplay.textContent = '‡∏£‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå...';
                }, 400);
            }
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        pauseBtn.onclick = returnToMenu;

        function gameLoop() {
            update();
            draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        createVirtualKeyboard();
        generateLevels();
        resizeCanvas();
        gameLoop();
    </script>
</body>

</html>
